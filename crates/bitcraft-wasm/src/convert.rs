//! Helpers for converting JSON schema definitions into core `bitcraft` types
//! and JavaScript‑friendly values.
//!
//! This module is internal; its functions back the public
//! [`WasmSchema`](crate::WasmSchema) API by:
//!
//! - Converting [`SchemaDef`](crate::schema_def::SchemaDef) into
//!   `bitcraft::field::Field` values.
//! - Building `bitcraft_transform::Transform` values from
//!   [`TransformDef`](crate::transform_def::TransformDef).
//! - Converting parsed values into `JsValue` so they can be consumed
//!   ergonomically from JavaScript/TypeScript.
use std::collections::BTreeMap;

use serde::Serialize;
use wasm_bindgen::JsValue;

/// Serializable representation of a parsed value that can be converted to `JsValue`.
///
/// This mirrors [`bitcraft_transform::Value`] but uses concrete Rust types that
/// can be serialized via `serde` and then passed through `serde_wasm_bindgen`
/// into JavaScript.
#[derive(Serialize)]
#[serde(untagged)]
pub enum JsValueOut {
    Int(i64),
    Float32(f32),
    Float64(f64),
    String(String),
    Bytes(Vec<u8>),
    Array(Vec<JsValueOut>),
}

/// Converts a `bitcraft_transform::Value` into the serializable [`JsValueOut`] shape.
fn value_to_js(v: bitcraft::transform::Value) -> JsValueOut {
    match v {
        bitcraft::transform::Value::Int(x) => JsValueOut::Int(x),
        bitcraft::transform::Value::Float32(x) => JsValueOut::Float32(x),
        bitcraft::transform::Value::Float64(x) => JsValueOut::Float64(x),
        bitcraft::transform::Value::String(x) => JsValueOut::String(x),
        bitcraft::transform::Value::Bytes(x) => JsValueOut::Bytes(x),
        bitcraft::transform::Value::Array(xs) => {
            JsValueOut::Array(xs.into_iter().map(value_to_js).collect())
        }
    }
}

/// Converts a map of parsed values into a JavaScript object.
///
/// Keys are field names and values are first converted into [`JsValueOut`]
/// and then into `JsValue` via `serde_wasm_bindgen`.
pub fn map_to_js(map: BTreeMap<String, bitcraft::transform::Value>) -> Result<JsValue, JsValue> {
    let out: BTreeMap<String, JsValueOut> =
        map.into_iter().map(|(k, v)| (k, value_to_js(v))).collect();

    serde_wasm_bindgen::to_value(&out).map_err(error_to_js)
}

/// Converts any debug‑printable error into a `JsValue` with a human‑readable message.
///
/// This keeps the surface area of error handling small on the JavaScript side
/// while still retaining detailed information that can be logged or surfaced
/// in developer tools.
pub fn error_to_js<T>(e: T) -> JsValue
where
    T: std::fmt::Debug,
{
    JsValue::from_str(&format!("{e:?}"))
}

pub fn convert_json_value(v: serde_json::Value) -> Result<bitcraft::assembly::Value, JsValue> {
    match v {
        serde_json::Value::Number(n) => {
            if let Some(i) = n.as_i64() {
                return Ok(bitcraft::assembly::Value::I64(i));
            }

            if let Some(u) = n.as_u64() {
                return Ok(bitcraft::assembly::Value::U64(u));
            }

            if let Some(f) = n.as_f64() {
                return Ok(bitcraft::assembly::Value::U64(f.to_bits())); // float as raw bits
            }

            Err(JsValue::from_str("Invalid number"))
        }

        serde_json::Value::Array(arr) => {
            let mut out = Vec::with_capacity(arr.len());
            for item in arr {
                out.push(convert_json_value(item)?);
            }
            Ok(bitcraft::assembly::Value::Array(out))
        }

        _ => Err(JsValue::from_str("Unsupported value type")),
    }
}
